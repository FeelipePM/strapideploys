{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initialState = exports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immer = _interopRequireDefault(require(\"immer\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _updateConditionsToFalse = _interopRequireDefault(require(\"./utils/updateConditionsToFalse\"));\n\nvar _updateValues = _interopRequireDefault(require(\"./utils/updateValues\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar initialState = {\n  initialData: {},\n  modifiedData: {},\n  layouts: {}\n};\n/* eslint-disable consistent-return */\n\nexports.initialState = initialState;\n\nvar reducer = function reducer(state, action) {\n  return (0, _immer[\"default\"])(state, function (draftState) {\n    switch (action.type) {\n      // This action is called when a checkbox in the <GlobalActions />\n      // changes\n      case 'ON_CHANGE_COLLECTION_TYPE_GLOBAL_ACTION_CHECKBOX':\n        {\n          var collectionTypeKind = action.collectionTypeKind,\n              actionId = action.actionId,\n              value = action.value;\n          var pathToData = ['modifiedData', collectionTypeKind];\n          Object.keys((0, _lodash.get)(state, pathToData)).forEach(function (collectionType) {\n            var collectionTypeActionData = (0, _lodash.get)(state, [].concat(pathToData, [collectionType, actionId]), undefined);\n\n            if (collectionTypeActionData) {\n              var updatedValues = (0, _updateValues[\"default\"])(collectionTypeActionData, value); // We need to remove the applied conditions\n\n              if (!value && updatedValues.conditions) {\n                var updatedConditions = (0, _updateValues[\"default\"])(updatedValues.conditions, false);\n                updatedValues = _objectSpread(_objectSpread({}, updatedValues), {}, {\n                  conditions: updatedConditions\n                });\n              }\n\n              (0, _lodash.set)(draftState, [].concat(pathToData, [collectionType, actionId]), updatedValues);\n            }\n          });\n          break;\n        }\n\n      case 'ON_CHANGE_COLLECTION_TYPE_ROW_LEFT_CHECKBOX':\n        {\n          var pathToCollectionType = action.pathToCollectionType,\n              propertyName = action.propertyName,\n              rowName = action.rowName,\n              _value = action.value;\n          var nextModifiedDataState = (0, _lodash.cloneDeep)(state.modifiedData);\n          var pathToModifiedDataCollectionType = pathToCollectionType.split('..');\n          var objToUpdate = (0, _lodash.get)(nextModifiedDataState, pathToModifiedDataCollectionType, {});\n          Object.keys(objToUpdate).forEach(function (actionId) {\n            // When a ct has multiple properties (ex: locales, field)\n            // We need to make sure that we add any new property to the modifiedData\n            // object.\n            if ((0, _lodash.has)(objToUpdate[actionId], \"properties.\".concat(propertyName))) {\n              var objValue = (0, _lodash.get)(objToUpdate, [actionId, 'properties', propertyName, rowName]);\n              var pathToDataToSet = [].concat((0, _toConsumableArray2[\"default\"])(pathToModifiedDataCollectionType), [actionId, 'properties', propertyName, rowName]);\n\n              if (!(0, _lodash.isObject)(objValue)) {\n                (0, _lodash.set)(nextModifiedDataState, pathToDataToSet, _value);\n              } else {\n                var updatedValue = (0, _updateValues[\"default\"])(objValue, _value);\n                (0, _lodash.set)(nextModifiedDataState, pathToDataToSet, updatedValue);\n              }\n            }\n          }); // When we uncheck a row, we need to check if we also need to disable the conditions\n\n          if (!_value) {\n            nextModifiedDataState = (0, _updateConditionsToFalse[\"default\"])(nextModifiedDataState);\n          }\n\n          (0, _lodash.set)(draftState, 'modifiedData', nextModifiedDataState);\n          break;\n        }\n\n      case 'ON_CHANGE_CONDITIONS':\n        {\n          Object.entries(action.conditions).forEach(function (array) {\n            var _array = (0, _slicedToArray2[\"default\"])(array, 2),\n                stringPathToData = _array[0],\n                conditionsToUpdate = _array[1];\n\n            (0, _lodash.set)(draftState, ['modifiedData'].concat((0, _toConsumableArray2[\"default\"])(stringPathToData.split('..')), ['conditions']), conditionsToUpdate);\n          });\n          break;\n        }\n\n      case 'ON_CHANGE_SIMPLE_CHECKBOX':\n        {\n          var _nextModifiedDataState = (0, _lodash.cloneDeep)(state.modifiedData);\n\n          (0, _lodash.set)(_nextModifiedDataState, (0, _toConsumableArray2[\"default\"])(action.keys.split('..')), action.value); // When we uncheck a single checkbox we need to remove the conditions from the parent\n\n          if (!action.value) {\n            _nextModifiedDataState = (0, _updateConditionsToFalse[\"default\"])(_nextModifiedDataState);\n          }\n\n          (0, _lodash.set)(draftState, 'modifiedData', _nextModifiedDataState);\n          break;\n        }\n\n      /*\n       * Here the idea is to retrieve a specific value of the modifiedObject\n       * then update all the boolean values of the retrieved one\n       * and update the drafState.\n       *\n       * For instance in order to enable create action for all the fields and locales\n       * of the restaurant content type we need to :\n       * 1. Retrieve the modifiedData.collectionTypes.restaurant.create object\n       * 2. Toggle all the end boolean values to the desired one\n       * 3. Update the draftState\n       *\n       * Since the case works well in order to update what we called \"parent\" checkbox. We can\n       * reuse the action when we need to toggle change all the values that depends on this one.\n       * A parent checkbox is a checkbox which value is not a boolean but depends on its children ones, therefore,\n       * a parent checkbox does not have a represented value in the draftState, they are just helpers.\n       *\n       * Given the following data:\n       *\n       * const data = {\n       *  restaurant: {\n       *   create: {\n       *     fields: { name: true },\n       *     locales: { en: false }\n       *   }\n       *  }\n       * }\n       *\n       * The value of the create checkbox for the restaurant will be Æ’alse since not all its children have\n       * truthy values and in order to set its value to true when need to have all the values of its children set to true.\n       *\n       * Similarly, we can reuse the logic for the components attributes\n       *\n       */\n\n      case 'ON_CHANGE_TOGGLE_PARENT_CHECKBOX':\n        {\n          var keys = action.keys,\n              _value2 = action.value;\n          var pathToValue = (0, _toConsumableArray2[\"default\"])(keys.split('..'));\n\n          var _nextModifiedDataState2 = (0, _lodash.cloneDeep)(state.modifiedData);\n\n          var oldValues = (0, _lodash.get)(_nextModifiedDataState2, pathToValue, {});\n          var updatedValues = (0, _updateValues[\"default\"])(oldValues, _value2);\n          (0, _lodash.set)(_nextModifiedDataState2, pathToValue, updatedValues); // When we uncheck a parent checkbox we need to remove the associated conditions\n\n          if (!_value2) {\n            _nextModifiedDataState2 = (0, _updateConditionsToFalse[\"default\"])(_nextModifiedDataState2);\n          }\n\n          (0, _lodash.set)(draftState, ['modifiedData'], _nextModifiedDataState2);\n          break;\n        }\n\n      case 'RESET_FORM':\n        {\n          draftState.modifiedData = state.initialData;\n          break;\n        }\n\n      case 'SET_FORM_AFTER_SUBMIT':\n        {\n          draftState.initialData = state.modifiedData;\n          break;\n        }\n\n      default:\n        return draftState;\n    }\n  });\n};\n\nvar _default = reducer;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initialState = exports[\"default\"] = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _immer = _interopRequireWildcard(require(\"immer\"));\n\nvar _get = _interopRequireDefault(require(\"lodash/get\"));\n\nvar _set = _interopRequireDefault(require(\"lodash/set\"));\n\nvar _makeUnique = _interopRequireDefault(require(\"../../utils/makeUnique\"));\n\nvar _getRelationType = _interopRequireDefault(require(\"../../utils/getRelationType\"));\n\nvar _retrieveComponentsFromSchema = _interopRequireDefault(require(\"./utils/retrieveComponentsFromSchema\"));\n\nvar actions = _interopRequireWildcard(require(\"./constants\"));\n\nvar _excluded = [\"name\"],\n    _excluded2 = [\"name\"];\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar initialState = {\n  components: {},\n  contentTypes: {},\n  initialComponents: {},\n  initialContentTypes: {},\n  initialData: {},\n  modifiedData: {},\n  reservedNames: {},\n  isLoading: true,\n  isLoadingForDataToBeSet: true\n};\nexports.initialState = initialState;\nvar ONE_SIDE_RELATIONS = ['oneWay', 'manyWay'];\n\nvar getOppositeRelation = function getOppositeRelation(originalRelation) {\n  if (originalRelation === 'manyToOne') {\n    return 'oneToMany';\n  }\n\n  if (originalRelation === 'oneToMany') {\n    return 'manyToOne';\n  }\n\n  return originalRelation;\n};\n\nvar findAttributeIndex = function findAttributeIndex(schema, attributeToFind) {\n  return schema.schema.attributes.findIndex(function (_ref) {\n    var name = _ref.name;\n    return name === attributeToFind;\n  });\n};\n\nvar reducer = function reducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n  return (// eslint-disable-next-line consistent-return\n    (0, _immer[\"default\"])(state, function (draftState) {\n      switch (action.type) {\n        case actions.ADD_ATTRIBUTE:\n          {\n            var _action$attributeToSe = action.attributeToSet,\n                name = _action$attributeToSe.name,\n                rest = (0, _objectWithoutProperties2[\"default\"])(_action$attributeToSe, _excluded),\n                forTarget = action.forTarget,\n                targetUid = action.targetUid;\n            delete rest.createComponent;\n            var pathToDataToEdit = ['component', 'contentType'].includes(forTarget) ? [forTarget] : [forTarget, targetUid];\n            var currentAttributes = (0, _get[\"default\"])(state, ['modifiedData'].concat(pathToDataToEdit, ['schema', 'attributes']), []).slice(); // Add the createdAttribute\n\n            var updatedAttributes = [].concat((0, _toConsumableArray2[\"default\"])(currentAttributes), [_objectSpread(_objectSpread({}, rest), {}, {\n              name: name\n            })]);\n            (0, _set[\"default\"])(draftState, ['modifiedData'].concat(pathToDataToEdit, ['schema', 'attributes']), updatedAttributes);\n\n            if (action.shouldAddComponentToData) {\n              var componentToAddUID = rest.component;\n              var componentToAdd = state.components[componentToAddUID];\n              var isTemporaryComponent = componentToAdd.isTemporary;\n              var hasComponentAlreadyBeenAdded = state.modifiedData.components[componentToAddUID] !== undefined;\n\n              if (isTemporaryComponent || hasComponentAlreadyBeenAdded) {\n                break;\n              } // Add the added component to the modifiedData.components\n\n\n              draftState.modifiedData.components[componentToAddUID] = componentToAdd;\n              var nestedComponents = (0, _retrieveComponentsFromSchema[\"default\"])(componentToAdd.schema.attributes, state.components); // We dont' need to set the already added components otherwise all modifications will be lost so we need to only add the not modified ones\n\n              var nestedComponentsToAddInModifiedData = nestedComponents.filter(function (compoUID) {\n                return (0, _get[\"default\"])(state, ['modifiedData', 'components', compoUID]) === undefined;\n              });\n              nestedComponentsToAddInModifiedData.forEach(function (compoUID) {\n                var compoSchema = (0, _get[\"default\"])(state, ['components', compoUID], {});\n                var isTemporary = compoSchema.isTemporary || false; // If the nested component has not been saved we don't need to add them as they are already in the state\n\n                if (!isTemporary) {\n                  draftState.modifiedData.components[compoUID] = compoSchema;\n                }\n              });\n              break;\n            }\n\n            var isCreatingRelationAttribute = rest.type === 'relation';\n\n            if (isCreatingRelationAttribute) {\n              var target = rest.target;\n              var targetAttribute = rest.targetAttribute || null;\n              var relation = rest.relation;\n              var relationType = (0, _getRelationType[\"default\"])(relation, targetAttribute);\n              var currentUid = (0, _get[\"default\"])(state, ['modifiedData'].concat(pathToDataToEdit, ['uid'])); // When the user in creating a relation with the same content type we need to create another attribute\n              // that is the opposite of the created one\n\n              if (rest.type === 'relation' && relationType !== 'oneWay' && relationType !== 'manyWay' && target === currentUid) {\n                var oppositeAttribute = {\n                  name: targetAttribute,\n                  relation: getOppositeRelation(relationType),\n                  target: target,\n                  targetAttribute: name,\n                  type: 'relation'\n                };\n\n                if (rest[\"private\"]) {\n                  oppositeAttribute[\"private\"] = rest[\"private\"];\n                }\n\n                var attributesToSet = [].concat((0, _toConsumableArray2[\"default\"])(updatedAttributes), [oppositeAttribute]);\n                (0, _set[\"default\"])(draftState, ['modifiedData'].concat(pathToDataToEdit, ['schema', 'attributes']), attributesToSet);\n              }\n            }\n\n            break;\n          }\n\n        case actions.ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE:\n          {\n            var dynamicZoneTarget = action.dynamicZoneTarget,\n                componentsToAdd = action.componentsToAdd;\n            var dzAttributeIndex = findAttributeIndex(state.modifiedData.contentType, dynamicZoneTarget);\n            componentsToAdd.forEach(function (componentUid) {\n              draftState.modifiedData.contentType.schema.attributes[dzAttributeIndex].components.push(componentUid);\n            });\n            break;\n          }\n\n        case actions.CHANGE_DYNAMIC_ZONE_COMPONENTS:\n          {\n            var _dynamicZoneTarget = action.dynamicZoneTarget,\n                newComponents = action.newComponents;\n\n            var _dzAttributeIndex = findAttributeIndex(state.modifiedData.contentType, _dynamicZoneTarget);\n\n            var currentDZComponents = state.modifiedData.contentType.schema.attributes[_dzAttributeIndex].components;\n            var updatedComponents = (0, _makeUnique[\"default\"])([].concat((0, _toConsumableArray2[\"default\"])(currentDZComponents), (0, _toConsumableArray2[\"default\"])(newComponents)));\n            draftState.modifiedData.contentType.schema.attributes[_dzAttributeIndex].components = updatedComponents; // Retrieve all the components that needs to be added to the modifiedData.components\n\n            var _nestedComponents = (0, _retrieveComponentsFromSchema[\"default\"])((0, _immer.current)(draftState.modifiedData.contentType.schema.attributes), state.components); // We dont' need to set the already added components otherwise all modifications will be lost so we need to only add the not modified ones\n\n\n            var _nestedComponentsToAddInModifiedData = _nestedComponents.filter(function (compoUID) {\n              return (0, _get[\"default\"])(state, ['modifiedData', 'components', compoUID]) === undefined;\n            });\n\n            _nestedComponentsToAddInModifiedData.forEach(function (compoUID) {\n              var compoSchema = (0, _get[\"default\"])(state, ['components', compoUID], {});\n              var isTemporary = compoSchema.isTemporary || false; // If the nested component has not been saved we don't need to add them as they are already in the state\n\n              if (!isTemporary) {\n                draftState.modifiedData.components[compoUID] = compoSchema;\n              }\n            });\n\n            break;\n          }\n\n        case actions.CREATE_COMPONENT_SCHEMA:\n          {\n            var newSchema = {\n              uid: action.uid,\n              isTemporary: true,\n              category: action.componentCategory,\n              schema: _objectSpread(_objectSpread({}, action.data), {}, {\n                attributes: []\n              })\n            };\n            draftState.components[action.uid] = newSchema;\n\n            if (action.shouldAddComponentToData) {\n              draftState.modifiedData.components[action.uid] = newSchema;\n            }\n\n            break;\n          }\n\n        case actions.CREATE_SCHEMA:\n          {\n            var _newSchema = {\n              uid: action.uid,\n              isTemporary: true,\n              schema: _objectSpread(_objectSpread({}, action.data), {}, {\n                attributes: []\n              })\n            };\n            draftState.contentTypes[action.uid] = _newSchema;\n            break;\n          }\n\n        case actions.EDIT_ATTRIBUTE:\n          {\n            var _action$attributeToSe2 = action.attributeToSet,\n                _name = _action$attributeToSe2.name,\n                _rest = (0, _objectWithoutProperties2[\"default\"])(_action$attributeToSe2, _excluded2),\n                _forTarget = action.forTarget,\n                _targetUid = action.targetUid,\n                initialAttribute = action.initialAttribute;\n\n            var initialAttributeName = initialAttribute.name;\n\n            var _pathToDataToEdit = ['component', 'contentType'].includes(_forTarget) ? [_forTarget] : [_forTarget, _targetUid];\n\n            var initialAttributeIndex = findAttributeIndex((0, _get[\"default\"])(state, ['modifiedData'].concat(_pathToDataToEdit)), initialAttributeName);\n            var isEditingRelation = _rest.type === 'relation';\n\n            if (!isEditingRelation) {\n              (0, _set[\"default\"])(draftState, ['modifiedData'].concat(_pathToDataToEdit, ['schema', 'attributes', initialAttributeIndex]), action.attributeToSet);\n              break;\n            }\n\n            var _updatedAttributes = (0, _get[\"default\"])(state, ['modifiedData'].concat(_pathToDataToEdit, ['schema', 'attributes'])).slice(); // First create the current relation attribute updated\n\n\n            var toSet = {\n              name: _name,\n              relation: _rest.relation,\n              target: _rest.target,\n              targetAttribute: _rest.targetAttribute,\n              type: 'relation'\n            };\n\n            if (_rest[\"private\"]) {\n              toSet[\"private\"] = _rest[\"private\"];\n            }\n\n            var currentAttributeIndex = _updatedAttributes.findIndex(function (_ref2) {\n              var name = _ref2.name;\n              return name === initialAttribute.name;\n            }); // First set it in the updatedAttributes\n\n\n            if (currentAttributeIndex !== -1) {\n              _updatedAttributes.splice(currentAttributeIndex, 1, toSet);\n            }\n\n            var oppositeAttributeNameToRemove = null;\n            var oppositeAttributeNameToUpdate = null;\n            var oppositeAttributeToCreate = null;\n\n            var _currentUid = (0, _get[\"default\"])(state, ['modifiedData'].concat(_pathToDataToEdit, ['uid']));\n\n            var didChangeTargetRelation = initialAttribute.target !== _rest.target;\n            var didCreateInternalRelation = _rest.target === _currentUid;\n\n            var _relationType = (0, _getRelationType[\"default\"])(_rest.relation, _rest.targetAttribute);\n\n            var initialRelationType = (0, _getRelationType[\"default\"])(initialAttribute.relation, initialAttribute.targetAttribute);\n            var hadInternalRelation = initialAttribute.target === _currentUid;\n            var didChangeRelationType = initialRelationType !== _relationType;\n            var shouldRemoveOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && !didCreateInternalRelation && hadInternalRelation && isEditingRelation;\n            var shouldRemoveOppositeAttributeBecauseOfRelationTypeChange = didChangeRelationType && hadInternalRelation && ['oneWay', 'manyWay'].includes(_relationType) && isEditingRelation;\n            var shouldUpdateOppositeAttributeBecauseOfRelationTypeChange = !ONE_SIDE_RELATIONS.includes(initialRelationType) && !ONE_SIDE_RELATIONS.includes(_relationType) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;\n            var shouldCreateOppositeAttributeBecauseOfRelationTypeChange = ONE_SIDE_RELATIONS.includes(initialRelationType) && !ONE_SIDE_RELATIONS.includes(_relationType) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;\n            var shouldCreateOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && didCreateInternalRelation && !ONE_SIDE_RELATIONS.includes(_relationType); // Store opposite attribute name to remove at the end of the loop\n\n            if (shouldRemoveOppositeAttributeBecauseOfTargetChange || shouldRemoveOppositeAttributeBecauseOfRelationTypeChange) {\n              oppositeAttributeNameToRemove = initialAttribute.targetAttribute;\n            } // In case of oneWay or manyWay relation there isn't an opposite attribute\n\n\n            if (oppositeAttributeNameToRemove) {\n              var indexToRemove = _updatedAttributes.findIndex(function (_ref3) {\n                var name = _ref3.name;\n                return name === oppositeAttributeNameToRemove;\n              });\n\n              _updatedAttributes.splice(indexToRemove, 1);\n            } // Create the opposite attribute\n\n\n            if (shouldCreateOppositeAttributeBecauseOfRelationTypeChange || shouldCreateOppositeAttributeBecauseOfTargetChange) {\n              oppositeAttributeToCreate = {\n                name: _rest.targetAttribute,\n                relation: getOppositeRelation(_relationType),\n                target: _rest.target,\n                targetAttribute: _name,\n                type: 'relation'\n              };\n\n              if (_rest[\"private\"]) {\n                oppositeAttributeToCreate[\"private\"] = _rest[\"private\"];\n              }\n\n              var indexOfInitialAttribute = _updatedAttributes.findIndex(function (_ref4) {\n                var name = _ref4.name;\n                return name === initialAttribute.name;\n              });\n\n              var indexOfUpdatedAttribute = _updatedAttributes.findIndex(function (_ref5) {\n                var attrName = _ref5.name;\n                return _name === attrName;\n              });\n\n              var indexToInsert = (indexOfInitialAttribute === -1 ? indexOfUpdatedAttribute : indexOfInitialAttribute) + 1;\n\n              _updatedAttributes.splice(indexToInsert, 0, oppositeAttributeToCreate);\n            }\n\n            if (shouldUpdateOppositeAttributeBecauseOfRelationTypeChange) {\n              oppositeAttributeNameToUpdate = initialAttribute.targetAttribute;\n              oppositeAttributeToCreate = {\n                name: _rest.targetAttribute,\n                relation: getOppositeRelation(_relationType),\n                target: _rest.target,\n                targetAttribute: _name,\n                type: 'relation'\n              };\n\n              if (_rest[\"private\"]) {\n                oppositeAttributeToCreate[\"private\"] = _rest[\"private\"];\n              }\n\n              if (oppositeAttributeNameToUpdate) {\n                var indexToUpdate = _updatedAttributes.findIndex(function (_ref6) {\n                  var name = _ref6.name;\n                  return name === oppositeAttributeNameToUpdate;\n                });\n\n                _updatedAttributes.splice(indexToUpdate, 1, oppositeAttributeToCreate);\n              }\n            }\n\n            (0, _set[\"default\"])(draftState, ['modifiedData'].concat(_pathToDataToEdit, ['schema', 'attributes']), _updatedAttributes);\n            break;\n          }\n\n        case actions.GET_DATA_SUCCEEDED:\n          {\n            draftState.components = action.components;\n            draftState.initialComponents = action.components;\n            draftState.initialContentTypes = action.contentTypes;\n            draftState.contentTypes = action.contentTypes;\n            draftState.reservedNames = action.reservedNames;\n            draftState.isLoading = false;\n            break;\n          }\n\n        case actions.DELETE_NOT_SAVED_TYPE:\n          {\n            // Doing so will also reset the modified and the initial data\n            draftState.contentTypes = state.initialContentTypes;\n            draftState.components = state.initialComponents;\n            break;\n          }\n\n        case actions.RELOAD_PLUGIN:\n          {\n            return initialState;\n          }\n\n        case actions.REMOVE_COMPONENT_FROM_DYNAMIC_ZONE:\n          {\n            var _dzAttributeIndex2 = findAttributeIndex(state.modifiedData.contentType, action.dzName);\n\n            draftState.modifiedData.contentType.schema.attributes[_dzAttributeIndex2].components.splice(action.componentToRemoveIndex, 1);\n\n            break;\n          }\n\n        case actions.REMOVE_FIELD:\n          {\n            var mainDataKey = action.mainDataKey,\n                attributeToRemoveName = action.attributeToRemoveName;\n            var pathToAttributes = ['modifiedData', mainDataKey, 'schema', 'attributes'];\n            var attributeToRemoveIndex = findAttributeIndex(state.modifiedData[mainDataKey], attributeToRemoveName);\n            var pathToAttributeToRemove = [].concat(pathToAttributes, [attributeToRemoveIndex]);\n            var attributeToRemoveData = (0, _get[\"default\"])(state, pathToAttributeToRemove);\n            var isRemovingRelationAttribute = attributeToRemoveData.type === 'relation'; // Only content types can have relations with themselves since\n            // components can only have oneWay or manyWay relations\n\n            var canTheAttributeToRemoveHaveARelationWithItself = mainDataKey === 'contentType';\n\n            if (isRemovingRelationAttribute && canTheAttributeToRemoveHaveARelationWithItself) {\n              var _target = attributeToRemoveData.target,\n                  _relation = attributeToRemoveData.relation,\n                  _targetAttribute = attributeToRemoveData.targetAttribute;\n\n              var _relationType2 = (0, _getRelationType[\"default\"])(_relation, _targetAttribute);\n\n              var uid = state.modifiedData.contentType.uid;\n              var shouldRemoveOppositeAttribute = _target === uid && !ONE_SIDE_RELATIONS.includes(_relationType2);\n\n              if (shouldRemoveOppositeAttribute) {\n                var attributes = state.modifiedData[mainDataKey].schema.attributes.slice();\n                var nextAttributes = attributes.filter(function (attribute) {\n                  if (attribute.name === attributeToRemoveName) {\n                    return false;\n                  }\n\n                  if (attribute.target === uid && attribute.targetAttribute === attributeToRemoveName) {\n                    return false;\n                  }\n\n                  return true;\n                });\n                draftState.modifiedData[mainDataKey].schema.attributes = nextAttributes;\n                break;\n              }\n            } // Find all uid fields that have the targetField set to the field we are removing\n\n\n            var uidFieldsToUpdate = state.modifiedData[mainDataKey].schema.attributes.slice().reduce(function (acc, current) {\n              if (current.type !== 'uid') {\n                return acc;\n              }\n\n              if (current.targetField !== attributeToRemoveName) {\n                return acc;\n              }\n\n              acc.push(current.name);\n              return acc;\n            }, []);\n            uidFieldsToUpdate.forEach(function (fieldName) {\n              var fieldIndex = findAttributeIndex(state.modifiedData[mainDataKey], fieldName);\n              delete draftState.modifiedData[mainDataKey].schema.attributes[fieldIndex].targetField;\n            });\n            draftState.modifiedData[mainDataKey].schema.attributes.splice(attributeToRemoveIndex, 1);\n            break;\n          }\n\n        case actions.REMOVE_FIELD_FROM_DISPLAYED_COMPONENT:\n          {\n            var _attributeToRemoveName = action.attributeToRemoveName,\n                componentUid = action.componentUid;\n\n            var _attributeToRemoveIndex = findAttributeIndex(state.modifiedData.components[componentUid], _attributeToRemoveName);\n\n            draftState.modifiedData.components[componentUid].schema.attributes.splice(_attributeToRemoveIndex, 1);\n            break;\n          }\n\n        case actions.SET_MODIFIED_DATA:\n          {\n            draftState.isLoadingForDataToBeSet = false;\n            draftState.initialData = action.schemaToSet;\n            draftState.modifiedData = action.schemaToSet; // Reset the state with the initial data\n            // All created components and content types will be lost\n\n            if (!action.hasJustCreatedSchema) {\n              draftState.components = state.initialComponents;\n              draftState.contentTypes = state.initialContentTypes;\n            }\n\n            break;\n          }\n\n        case actions.UPDATE_SCHEMA:\n          {\n            var _action$data = action.data,\n                displayName = _action$data.displayName,\n                category = _action$data.category,\n                icon = _action$data.icon,\n                kind = _action$data.kind,\n                schemaType = action.schemaType,\n                _uid = action.uid;\n            draftState.modifiedData[schemaType].schema.displayName = displayName;\n\n            if (action.schemaType === 'component') {\n              draftState.modifiedData.component.category = category;\n              draftState.modifiedData.component.schema.icon = icon;\n              var addedComponent = (0, _immer.current)(draftState.modifiedData.component);\n              draftState.components[_uid] = addedComponent;\n              break;\n            }\n\n            draftState.modifiedData.contentType.schema.kind = kind;\n            break;\n          }\n\n        default:\n          return draftState;\n      }\n    })\n  );\n};\n\nvar _default = reducer;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}
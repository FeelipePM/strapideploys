{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _at5 = _interopRequireDefault(require(\"lodash/at\"));\n\nvar _helperPlugin = require(\"@strapi/helper-plugin\");\n\nvar _layout = _interopRequireDefault(require(\"../layout\"));\n\nvar _Modal = _interopRequireDefault(require(\"./components/Modal\"));\n\nvar _reducer = _interopRequireWildcard(require(\"./reducer\"));\n\nvar _Stepper = _interopRequireDefault(require(\"./components/Stepper\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar GuidedTourModal = function GuidedTourModal() {\n  var _useGuidedTour = (0, _helperPlugin.useGuidedTour)(),\n      currentStep = _useGuidedTour.currentStep,\n      guidedTourState = _useGuidedTour.guidedTourState,\n      setCurrentStep = _useGuidedTour.setCurrentStep,\n      setStepState = _useGuidedTour.setStepState,\n      isGuidedTourVisible = _useGuidedTour.isGuidedTourVisible,\n      setSkipped = _useGuidedTour.setSkipped;\n\n  var _useState = (0, _react.useState)(currentStep),\n      _useState2 = (0, _slicedToArray2[\"default\"])(_useState, 2),\n      isVisible = _useState2[0],\n      setIsVisible = _useState2[1];\n\n  var _useReducer = (0, _react.useReducer)(_reducer[\"default\"], _reducer.initialState),\n      _useReducer2 = (0, _slicedToArray2[\"default\"])(_useReducer, 2),\n      _useReducer2$ = _useReducer2[0],\n      stepContent = _useReducer2$.stepContent,\n      sectionIndex = _useReducer2$.sectionIndex,\n      stepIndex = _useReducer2$.stepIndex,\n      hasSectionAfter = _useReducer2$.hasSectionAfter,\n      hasStepAfter = _useReducer2$.hasStepAfter,\n      dispatch = _useReducer2[1];\n\n  var _useTracking = (0, _helperPlugin.useTracking)(),\n      trackUsage = _useTracking.trackUsage;\n\n  (0, _react.useEffect)(function () {\n    if (!currentStep) {\n      setIsVisible(false);\n      return;\n    }\n\n    var _at = (0, _at5[\"default\"])(guidedTourState, currentStep),\n        _at2 = (0, _slicedToArray2[\"default\"])(_at, 1),\n        isStepDone = _at2[0];\n\n    setIsVisible(!isStepDone && isGuidedTourVisible);\n  }, [currentStep, guidedTourState, isGuidedTourVisible]);\n  (0, _react.useEffect)(function () {\n    if (currentStep) {\n      var _at3 = (0, _at5[\"default\"])(_layout[\"default\"], currentStep),\n          _at4 = (0, _slicedToArray2[\"default\"])(_at3, 1),\n          content = _at4[0];\n\n      var sectionKeys = Object.keys(guidedTourState);\n\n      var _currentStep$split = currentStep.split('.'),\n          _currentStep$split2 = (0, _slicedToArray2[\"default\"])(_currentStep$split, 2),\n          sectionName = _currentStep$split2[0],\n          stepName = _currentStep$split2[1];\n\n      var newSectionIndex = sectionKeys.indexOf(sectionName);\n      var newStepIndex = Object.keys(guidedTourState[sectionName]).indexOf(stepName);\n      var newHasSectionAfter = newSectionIndex < sectionKeys.length - 1;\n      var newHasStepAfter = newStepIndex < Object.keys(guidedTourState[sectionName]).length - 1;\n      dispatch({\n        type: 'UPDATE_MODAL',\n        content: content,\n        newSectionIndex: newSectionIndex,\n        newStepIndex: newStepIndex,\n        newHasSectionAfter: newHasSectionAfter,\n        newHasStepAfter: newHasStepAfter\n      });\n    }\n  }, [currentStep, guidedTourState]);\n\n  var handleCtaClick = function handleCtaClick() {\n    setStepState(currentStep, true);\n    trackUsage(stepContent.trackingEvent);\n    setCurrentStep(null);\n  };\n\n  var handleSkip = function handleSkip() {\n    setSkipped(true);\n    setCurrentStep(null);\n    trackUsage('didSkipGuidedtour');\n  };\n\n  if (isVisible && stepContent) {\n    return /*#__PURE__*/_react[\"default\"].createElement(_Modal[\"default\"], {\n      hideSkip: !hasStepAfter && !hasSectionAfter,\n      onSkip: handleSkip,\n      onClose: handleCtaClick\n    }, /*#__PURE__*/_react[\"default\"].createElement(_Stepper[\"default\"], (0, _extends2[\"default\"])({}, stepContent, {\n      onCtaClick: handleCtaClick,\n      currentStep: currentStep,\n      sectionIndex: sectionIndex,\n      stepIndex: stepIndex,\n      hasSectionAfter: hasSectionAfter\n    })));\n  }\n\n  return null;\n};\n\nvar _default = GuidedTourModal;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}